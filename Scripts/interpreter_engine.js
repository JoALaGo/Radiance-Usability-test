//This is a rudimentary version of the interpreter. It will only contemplate the basic features of the BBCP, excluding the parameters
//available in the initialization section of Radiance
//For now it will only include pseudocode and some plantuml diagrams to guide myself
//----------- (L) labels-----
//WARNING: features that are currently rudimentary and should be improved
//------------(A) Simulation requisites-----------------
//Variables: 
// var initialized_profiles = new Object(); <-- to store all the profiles that will be used during the simulation
// var evaluate_profiles= []; <---- an array with the profiles to evaluate at a specific point in time.
// var cooldown_profiles= []; <---- an array with the profiles in cooldown (can't be evaluated)
// var lock_minimum_run= []; <---- an array with the profiles that are locked in a run state due to the minimum run time definition
// var external_parameter_pool = []; <---- to store all the parameters that are generated by the operations (external parameters only).
// var resource_usage = [{profile_id:'',resource_usage:{ram:'',cpu:''...}}]
// var seconds_left = N; <---- to control the seconds left in the simulation.
var initialized_profiles = new Object();
var evaluate_profiles = new Object();
var cooldown_profiles = new Object();
var lock_minimum_run = new Object();
var external_parameter_pool = new Object();
var resource_usage = new Object();
var seconds_left = 0;
var current_second = 1;
var log = '';
var simulation_dataset = new Object();
var run_plot = null;
var simulations = [];
var log_reporting_active = false;

//to achieve certain states: 
/*
R = run
S = stop
L = locked
Lm = locked for minimum run time
C = cooldown
Aq = A valid quota
E= can be evaluated
--------------------------
Important axioms:
--------------------------
Lm -> R^!E: Profiles locked for a minimum run time are in a run state and can not be evaluated
E -> ~Lm^~L^~C
R -> Aq^E^~Lm^~C
*/

function printToLog(message, type) {
    
    if(this.log_reporting_active){
        log += "<br>";
    if (type == 'message') {
        log += ">" + message;
    } else {
        log += '-----' + message + '-----';
    }
}



}
//------------- (C) Seconds subroutines-----------------
// WEBWORKER!
// - Verify that the instant run time does not exceed the maximum run time, but respects the minimum run time
// - Verify that the profiles under an evaluation_lock have a (B) current_cooldown lower than the profile's cooldown
//
//
//----------STEP 1--------------
//
// We get a list of all the profiles included in the collection with no duplicates
function interpreterEngineInitialization() {
    console.time('Simulation');
    console.log("Initializing the interpreter");
    //we clear the log 
    let log = document.getElementById('interpreter_simulation_log').innerHTML = '';
    this.log = '';
    log.innerHTML = '';
    this.initialized_profiles = new Object();
    this.evaluate_profiles = new Object();
    this.cooldown_profiles = new Object();
    this.lock_minimum_run = new Object();
    this.external_parameter_pool = new Object();
    this.resource_usage = new Object();
    this.seconds_left = document.getElementById("interpreter_time_initialization").value;
    this.current_second = 1;//we always start in second 1
    var simulation_id = Date.now();
    var results_dataset = this.simulation_dataset[simulation_id] = {};
    this.simulation_dataset[simulation_id].run_stamps = {};
    this.simulation_dataset[simulation_id].stop_stamps = {};
    this.simulation_dataset[simulation_id].delta_quota = {};
    let log_reporting_active = false;
    simulations.push(simulation_id);

    //we get all the profiles of the collections for the interpreter
    //WARNING: Right now as a rudimentary implementation I will only care about 1 collection, it should be improved to search through all the collections and initialize the profiles needed
    let collection = getInstanceFromDb('collection', this.db.test_tube.collections[0].root_id);
    printToLog('Interpreter initialized', 'message');
    for (let x in collection.inner_profiles) {

        let profile_instance = getInstanceFromDb('profile', collection.inner_profiles[x]);
        console.log(JSON.stringify(profile_instance));
        //console.log('initializing ' + profile_instance.element_name + " profile", 'message');
        printToLog('initializing ' + profile_instance.element_name + " profile", 'message');
        this.simulation_dataset[simulation_id].run_stamps[profile_instance.element_id] = [];
        // We create an object called "initialized profiles"
        //  - Each profile initialization should be included in initialized profiles as properties, so that the lookoup is quick.
        // Result: initialized_profiles.1826108287[bbcp properties]
        //                             .8578611278[bbcp properties]
        //The [bbcp properties] are the parsed profiles cache of each profile
        this.initialized_profiles[collection.inner_profiles[x]] = JSON.parse(profile_instance.profile_cache);
        printToLog('<p style="color:green">success</p>', 'state');
        //(B) Each profile should have the following properties assigned to them for the simulation, and the pertinent values initialized: 
        /* The places in the initialization for each property
            0. Profile_configuration
            1. Computation_centric
            2. Data_centric
            3. Conduct_centric
            4. Usage
            5. Run_constraints
            6. Expectations
            7. Cycles
            8. Timed_expectations
            9. Elasticity
            10. Run_constraints
            11. Events
            12. Timed_expectations
            13. Elasticity
            14. Run_constraints
            15. Operations
            16. resource_usage
            17. Run_constraints
            18. Operation_run_constraints
            19. Parameters
            20. Dependencies
            21. Operational
            22. Triggers
            23. Results
            */

        //  - delta_quota: to track the dyanamic quota; the quota that changes throughout the simulation.
        let current_obj = this.initialized_profiles[collection.inner_profiles[x]];
        current_obj['profile_name'] = getInstanceFromDb('profile', collection.inner_profiles[x]).element_name;
        current_obj['engine_variables'] = {};
        current_obj.engine_variables['delta_quota'] = parseInt(current_obj[5][1].quota);
        //  - current_cooldown: to track the cooldown during the simulation
        current_obj.engine_variables['delta_cooldown'] = current_obj[5][1].cooldown;
        //  - delta_evaluation: this will be the variable used to sum every value per evaluation until n mod 1 = 0, which give us the signal to evaluate
        current_obj.engine_variables['delta_evaluation'] = 0;
        //  - delta_instant_run_time: this will track the time that the profile has spent in a run time
        current_obj.engine_variables['delta_instant_run_time'] = 0;
        //  - current_state: to trace the state; true for run false for stop 
        current_obj.engine_variables['current_state'] = false;
        //  - delta_run_probability: to trace the change in run probability
        current_obj.engine_variables['delta_run_probability'] = current_obj[4][1].run_base_probability;
        //  - delta_stop_probabilit: to trace the change in stop probability
        current_obj.engine_variables['delta_stop_probability'] = current_obj[4][1].stop_base_probability;
        //  - delta_elasticity: to trace the change in elasticity according to timed expectations
        current_obj.engine_variables['delta_elasticity'] = 0;
        //  - delta_evaluation_counter: this will count the number of evaluations elapsed in the last state
        current_obj.engine_variables['delta_evaluation_counter'] = 0;
        //  - delta_elastic_evaluation_counter: this will count the number of evaluations elapsed in the last state under elasticity
        current_obj.engine_variables['delta_elastic_evaluation'] = 0;
        //  - delta_accumulated_run: this variable sums up all the time that the profile has spent in a run time
        current_obj.engine_variables['delta_accumulated_run'] = 0;
        //  - parameter_pool: this variable stores a quantity of pararmeter types generated {type:'parameter_id',quantity:'N'}
        current_obj.engine_variables['parameter_pool'] = [];
        //  - last_run: the time that has elapsed since the last run
        current_obj.engine_variables['last_run'] = 0;
        //  - evaluation_lock: it locks the profile in the state and avoids the profile from being evaluated
        current_obj.engine_variables['evaluation_lock'] = false;
        //Now that we have every profile needed initialized, we check that the EVALUATION RATE of every profile is not inferior than 1, right 
        //now I will not adapt the interpreter to meet sub-second frequencies of profile executions as this is just a rudimentary implementation




    }

    runEngine(simulation_id);

}

function runEngine(simulation_id) {
    printToLog('Starting the engine with ' + this.seconds_left + ' seconds left');
    let total_seconds = parseInt(this.seconds_left);
    this.simulation_dataset[simulation_id].time_initialization = total_seconds;
    let run_stamps = this.simulation_dataset[simulation_id].run_stamps;
    for (let x = 1; x <= total_seconds; x++) {


        //---------STEP 2----------------
        //We get all the profiles that have run probabilities, because they are the ones that will be evaluated, we place them in (A) EVALUATE_PROFILES
        //Now that we know which profiles to evaluate, we start the evaluation, checking each  second:
        // 1- add the evaluation rate to each (B) EVALUATION_DELTA of each profile IF the profile is not in (A) COOLDOWN_PROFILES AND (A)LOCK_MINIMUM_RUN; the evaluation_lock should be false
        //      1.1- at the time of adding to the evaluation rate we check if n mod 1 = 0, if it does we put the id of the profile to evaluate in (A) EVALUATE_PROFILES
        for (let y in Object.entries(this.initialized_profiles)) {
            let entry = Object.entries(this.initialized_profiles)[y][0];
            if (!this.cooldown_profiles.hasOwnProperty(entry) && !this.lock_minimum_run.hasOwnProperty(entry)) {
                let entry_instance = this.initialized_profiles[entry];
                let engine_variables = entry_instance.engine_variables;
                //we increment the delta_run_time if it was in a run state
                if (engine_variables.current_state == true) {
                    //PRE-EVALUATION RUN
                    //printToLog('instant run time: '+ engine_variables.delta_instant_run_time);
                    engine_variables.delta_instant_run_time = engine_variables.delta_instant_run_time + 1;


                    engine_variables.delta_accumulated_run = engine_variables.delta_accumulated_run + 1;


                    //we check if there was a quota assigned to the initialized profile
                    if (this.initialized_profiles[entry][5][1].quota >= 0) {

                        //a quota exists and we have to decrease delta quota
                        if (this.initialized_profiles[entry].engine_variables.delta_quota > 0) {
                            this.initialized_profiles[entry].engine_variables.delta_quota = this.initialized_profiles[entry].engine_variables.delta_quota - 1;
                            printToLog('quota decreased at ' + x + ', current quota: ' + this.initialized_profiles[entry].engine_variables.delta_quota);
                            if (this.initialized_profiles[entry].engine_variables.delta_quota == 0) {
                                //hey we spent the quota in this last second, we have to switch the profile to a stop state
                                printToLog('Profile ' + entry + ' spent all its quota at ' + x, 'state');
                                cascadeStopEffects(run_stamps, entry, this.initialized_profiles[entry].engine_variables.delta_instant_run_time, x, engine_variables);
                                //we are in an empty quota mode
                                //lock the profile

                                this.initialized_profiles[entry].evaluation_lock = true;
                                //switch the profile to a stop state
                                //place the locked profile in the cooldowned profiles object
                                this.cooldown_profiles[entry] = null;
                                if (this.initialized_profiles[entry].engine_variables.delta_cooldown > 0) {
                                    if (!this.cooldown_profiles.hasOwnProperty(entry)) {
                                        this.cooldown_profiles[entry] = null;
                                    }
                                    // we decrease the cooldown !---Not used as we should not contabilize the second at wich the cooldown is counted--!
                                    //this.initialized_profiles[entry].engine_variables.delta_cooldown = this.initialized_profiles[entry].engine_variables.delta_cooldown - 1;
                                    printToLog('current cooldown = ' + this.initialized_profiles[entry].engine_variables.delta_cooldown);
                                }
                            }
                        }

                    }
                } else {//the profile is in a stop state
                    engine_variables.delta_instant_run_time = 0;
                   
                }

                //we increment delta evaluation~Ø

                entry_instance.engine_variables.delta_evaluation += + parseFloat(entry_instance[4][1].profile_evaluation_rate);
                printToLog("delta evaluation: " + entry_instance.engine_variables.delta_evaluation + "at: " + x);

                if (entry_instance.engine_variables.delta_evaluation >= 1) {
                    printToLog('EVALUATION for ' + entry + " delta evaluation: " + entry_instance.engine_variables.delta_evaluation + "at: " + x);
                    this.evaluate_profiles[entry] = null;
                    entry_instance.engine_variables.delta_evaluation = entry_instance.engine_variables.delta_evaluation - 1;
                    if (entry_instance.engine_variables.delta_evaluation <= 0) {
                        //we enter a cooldown state
                        entry_instance.engine_variables.evaluation_lock = true;
                    }
                } else {
                    //printToLog('no evaluation for '+entry+" delta evaluation: "+entry_instance.engine_variables.delta_evaluation);
                    //we do not evaluate
                }

            } else {
                // this else was entered because either:
                // 1- the profile is in a cooldown
                // 2- the profile is locked in a minimum run
                let entry_instance = this.initialized_profiles[entry];
                let engine_variables = entry_instance.engine_variables;
                //we check if the current profile is either in a cooldown or locked in a minimum run
                if (this.cooldown_profiles.hasOwnProperty(entry)) {
                    if (engine_variables.delta_cooldown > 0) {

                        engine_variables.delta_cooldown = engine_variables.delta_cooldown - parseInt(1);
                        printToLog('Locked profile delta countdown: '+engine_variables.delta_cooldown);
                    } else {
                        //we reinitialize the quota
                        engine_variables.delta_quota = parseInt(this.initialized_profiles[entry][5][1].quota);
                        //reinitialize the cooldown
                        engine_variables.delta_cooldown = parseInt(this.initialized_profiles[entry][5][1].cooldown);
                        //bring the profile out of lock
                        engine_variables.evaluation_lock = false;
                        //we take the profile out of the cooldown object
                        delete this.cooldown_profiles[entry];
                        printToLog("Profile's " + entry + ' quota renewed at ' + x, 'state');
                    }

                }


            }
        }

        //---------STEP 3----------------
        //  1- we grab each profile in (A) EVALUATE_PROFILES and we check their state
        //      1.1- We check the (B) delta profile's run or stop probability and
        //      1.2- We check against a random number if we should switch to a stop or run.

        for (let y in Object.entries(this.evaluate_profiles)) {
            let probability = 0;
            let target_state;
            //console.log(x);
            //console.log(JSON.stringify(this.evaluate_profiles));
            //console.log(Object.entries(this.evaluate_profiles)[x]);
            //console.log(Object.entries(this.evaluate_profiles)[x][0]);
            let entry = Object.entries(this.evaluate_profiles)[y][0];
            if (this.initialized_profiles[entry].engine_variables.current_state == false) {
                probability = this.initialized_profiles[entry].engine_variables.delta_run_probability;
                target_state = true;//The profile enters a run state on a successful flif
            } else {
                probability = this.initialized_profiles[entry].engine_variables.delta_stop_probability;
                target_state = false;//The profile enters a stop state on a succesful flip
            }

            let flip = Math.random(0, 1);
            //printToLog("flip: "+flip+" probability: "+probability+" target state: "+target_state);
            let engine_variables = this.initialized_profiles[entry].engine_variables;
            if (flip <= probability) {

                engine_variables.current_state = target_state;
                if (target_state == false) {
                    //we switch the profile to a stop
                    engine_variables.current_state = false;
                    printToLog('<h6 style="color:red;">' + entry + ' Stopped after: ' + (parseInt(engine_variables.delta_instant_run_time)) + ' seconds at' + x + '</h6>');
                    //                      timestamp, time spent
                    //We log the stop to graph it later
                    cascadeStopEffects(run_stamps, entry, (engine_variables.delta_instant_run_time - 1), x);
                    engine_variables.delta_instant_run_time = 0;

                } else {
                    cascadeRunEffects(entry, x);
                }

            }
        }

        //we remove the profile from the evaluation object AFTER everything gets evaluated, otherwise the object updates and the index stated by X becomes undefined
        this.evaluate_profiles = new Object();




    }//end of the simulation

    engineEnd();

}


function engineEnd() {
    console.timeEnd('Simulation');
    //we print the messages to the log
    printToLog('<h5 style="color:green">Simulation ended successfully</h5>', 'state');
    for (let x in Object.entries(this.initialized_profiles)) {
        let entry = Object.entries(this.initialized_profiles)[x][0];
        let instance = getInstanceFromDb('profile', entry);
        printToLog('The profile ' + instance.element_name + ' spent ' + this.initialized_profiles[entry].engine_variables.delta_accumulated_run + ' seconds in a run state.', 'message');
    }
    if(this.log_reporting_active){
        document.getElementById('interpreter_simulation_log').innerHTML += log;
    }
    

    //we run the plotter
    runPlotInitialization()

}

function cascadeRunEffects(profile_id, time) {
    this.initialized_profiles[profile_id].current_state = true;
    printToLog('<h6 style="color:green;">' + profile_id + ' runs at: ' + time + '</h6>');
}
function cascadeStopEffects(run_stamps, profile_id, delta_instant_run_time, time) {
    printToLog('<h6 style="color:red;">' + profile_id + ' Stopped after: ' + delta_instant_run_time+ ' seconds at' + parseInt(time)-1 + '</h6>');

    console.log("cascadeStopEffects: stopped after "+delta_instant_run_time+" at "+time);
    run_stamps[profile_id].push({ 'spent': delta_instant_run_time, 'until': time - 1 });
    this.initialized_profiles[profile_id].current_state = false;
    this.initialized_profiles[profile_id].engine_variables.delta_instant_run_time = 0;


}

function runPlotInitialization() {
    if (this.run_plot == null) {
        /*  const layout = {
             xaxis: {range: [1, total_time], title: "Time Elapsed"},
             yaxis: {range: [0, 1], title: "Profile state"},
             title: "Profiles' states change over time"
           }; */
        console.log('lab plotter initialized');
        //we get the data for the plot
        
        //we get the latest simulation dataset in the array
        var trace1 = {

            x: [1, 2, 3, 4],

            y: [10, 15, 13, 17],

            mode: 'markers'

        };


        var trace2 = {

            x: [2, 3, 4, 5],

            y: [16, 5, 11, 9],

            mode: 'lines'

        };


        var trace3 = {

            x: [1, 2, 3, 4],

            y: [12, 9, 15, 12],

            mode: 'lines+markers'

        };


        var data = [trace1, trace2, trace3];


        var layout = {

            title: 'Engine results'

        };


        this.run_plot = Plotly.newPlot('run_plot', null, layout);


        // run_plotter = Plotly.newPlot( document.getElementById('run_plot'), ,layout);
    } else {

        let worker = new Worker("./Scripts/workers/interpreter_plot_run.js");
        worker.postMessage({ simulations: this.simulations, simulation_dataset: this.simulation_dataset, initialized_profiles: this.initialized_profiles });
        let datasets;//to store the result of the worker
        worker.onmessage = function (event) {
            datasets = event.data.datasets;
            console.log(datasets);
            //we get the simulation object

            Plotly.newPlot('run_plot', datasets, { title: 'Simulation ' + event.data.simulations[0] + ' Run Results', showlegend: true, yaxis: { range: [0, 1.2], title: { text: 'Profile State (1= Run)' } }, xaxis: { range: [1, event.data.simulation_dataset[event.data.simulations[0]].time_initialization], title: { text: 'Simulation time (Seconds)' } } }, { scrollZoom: true, editable: true });
        };



    }
}





//--------Test cases--------
// --DONE-- 0.9 Verify that the profile switches between run and stop
// --DONE-- Check that a profile responds to cooldown with a quota of 2 seconds and then a cooldown of 10 and a duration of 36 seconds.
// 2. check that a profile complies with minimum and maximum run times a maximum of 30 seconds, a minimum of 15 seconds and a 85 seconds of simulation
// 3. check that the delta probability changes adecuately under elasticity.

/* 4. Check Profile with Locking and Minimum Run Time:

    Profile has a minimum run time of 10 seconds.
    The simulation duration is 30 seconds.
    Initially, the profile starts in the run state.
    Check that the profile remains in the run state for the first 10 seconds due to the minimum run time constraint.
    After 10 seconds, the profile can transition freely between run and stop states based on probabilities. */
/* 
    5. Elasticity Test:

    Profile has a run probability that increases over time (delta_run_probability).
    The simulation duration is 60 seconds.
    Observe how the profile's run probability changes as the simulation progresses.
    Ensure that the profile adapts its behavior based on the changing run probability. */